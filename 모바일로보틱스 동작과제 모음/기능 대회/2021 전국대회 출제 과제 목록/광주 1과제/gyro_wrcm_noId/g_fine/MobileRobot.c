/************************************************************************************************************/
/*                                                                                                          */
/*                                              MobileRobot.c                                               */
/*                                                                                                          */
/*                                                                                       2020. 1. 1.        */
/************************************************************************************************************/
#include "Interface.h"


#define cw wa = 0;
#define ar acf =cacf= 0;
#define set pos[0] = pos[1] = pos[2] = 0;
#define gyroSet gyro = rearGyro = 0;

#define V3 while(!Cmd(0,19));
#define SV1 while(!Cmd(0,18));
#define reset bar_1 = bar_2 = bar_3 = bar_4 = bar_5 = 0;
#define wait if(key) {SS(); while(SW2); while(!SW2);}
#define lcs lcd_clear_screen();
int key= 0, key_puck = 0;

#define ab45    wa = 90; AB(0,0,4,199,5,164,50,0); cw
#define ab345(y) wa = 90; AB(3,126,4,199,5,164,50,y); cw
#define ab645(y) wa = 90; AB(6,144,4,199,5,164,50,y); cw
#define ab86 AB(0,0,6,136,8,112,50,0);

#define ab865(y) AB(5,195,6,173,8,125,30,y); cw

#define ab134(y) AB(4,188,1,165,3,158,30,y); cw
#define move_ab845(y) 		ar ab45(20);	Axis(-1,15,0,20,130);	cw ar AB(0,0,8,125,0,0,20,0);	SS();	Axis(0,-15,0,20,130);	ar ab45(20);	cw
#define move_ab145(y) 		ar ab45(20);	Axis(1,15,0,20,130);	cw ar AB(0,0,1,144,0,0,20,0);	SS();	Axis(0,-15,0,20,130);	ar ab45(20);	cw

#define L 1
#define R -1

#define tx 130
#define ty 90
//S구역 스캔 / b구역 벽체크 
int goalColor,sColor[2];
int aGate = 0, scanS,bGate[2] = {0},cGate;
int start,area,dir;
int line;
int solve[7] = {0};
int col[3] = {0};
int block[6][6] = {0},blockDetect = 0;

int main(void)
{

    Interface_init();

	write_gyro(0x1E, 1); // 지자기 OFF
	write_gyro(0x1E, 5); // 자이로 500dps	
	write_gyro(0x1E, 20); // 능동적 진동성분제거 OFF

	write_gyro(0x1E, 16); // 자이로 보정

	Camera_init();
	Setting(11);
	TM(50);
	V3

	_delay_ms(500);

	set

	LED_ON(3);
	_delay_ms(100);
	LED_OFF(3);

	while(1)
	{		
	    if(SW1)
		{
			key--;
			LED_ON(3);
			_delay_ms(100);
			LED_OFF(3);

		}
	    if(SW3)
		{
			key++;
			LED_ON(3);
			_delay_ms(100);
			LED_OFF(3);

		}
		
		
	    if(SW2)
		{
			lcd_clear_screen();
			LED_ON(3);
			_delay_ms(100);
			LED_OFF(3);

			switch(key)
			{

case 0:
case 1:

memset(block,0,sizeof(block));

//게이트 스캔 
if(g_psd[2] > 40) aGate = 0;
else if(g_psd[7] > 50) aGate = 2;
else if(g_psd[6] > 50) aGate = 3;
else aGate = 1; 

lcs lcd(1,1,"GATE : %d",aGate);	wait

if(aGate == 0 || aGate == 1){
	if(aGate == 0){
		At(-110,100);	wa = -20;
		Axis(-20,0,0,50,60);	wa=  70;
		Ot(-10,90,0,40,0);	wa = -20;

		CPsd(12,4,-5,3,18,0,50,0);
		CPsd(10,4,-5,5,18,0,50,0);
		CPsd(4,4,-1000,5,18,30,50,0);
		
		Avoid(5,14,18,23,-1000,50,0);
		goalColor = T(103,2);

		Ot(-12,90,20,40,0);	cw
		
		Od2(20,0,90,40,-50,60,130);	cw
		CPsd(12,1,5,3,14,0,50,60);
	}
	else if(aGate == 1){
		Ot(-28,-90,-70,40,50);	wa = 20;
		Avoid(4,14,18,23,-1000,50,0);	

		goalColor = T(103,2);
		Ot(-12,90,0,40,0);	
		Od2(20,0,70,40,-50,60,130);	cw
		
		CPsd(12,1,5,3,14,0,50,60);
		CPsd(10,1,50,5,14,0,50,0);
	}
	
	line = CPsd(13,1,1000,5,14,0,50,0);
	
	if(line == goalColor){
		CPsd(8,1,1000,3,14,30,50,0);
		Ad(3,44,-90,40,-50,100);

		ar ab45(30);
		area = 4;
		dir = -1;
	}
	else{
		block[4][5] = 1;
		block[5][4] = 1;
		blockDetect = 1;

		Drift(0,10,20,40,-50);	wa = 20;

		CPsd(12,3,-5,3,18,0,50,60);
		CPsd(10,3,-60,5,18,0,50,0);
		CPsd(-4,3,-1000,5,18,22,50,0);
		Ot(-12,90,20,40,0);	wa = 40;
		Axis(5,0,0,40,0);	wa = -50;
		Ot(-20,-90,0,40,0);	wa = 40;
		Ad(0,-15,-40,40,-50,60);	cw

		ar ab345(20);
		area = 5;
		dir = 1;

	}
}

else if(aGate == 2 || aGate == 3){
	if(aGate == 2){
		At(110,100);	wa = 20;
		Axis(17,0,0,50,60);	wa=  -70;
		Ot(-10,-90,0,40,0);	wa = 20;

		CPsd(12,5,-5,3,14,0,50,0);
		CPsd(10,5,-5,5,14,0,50,0);
		CPsd(5,5,-1000,5,14,25,50,0);
		
		Avoid(4,14,18,23,-1000,50,0);
		goalColor = T(103,2);

		Ot(-12,-90,-20,40,0);	cw
		
		Od2(-20,0,-90,40,-50,60,130);	cw
		CPsd(12,8,5,3,18,0,50,60);
	}
	else if(aGate == 3){
		Ot(-28,90,70,40,50);	wa = -20;
	
		Avoid(5,14,18,23,-1000,50,0);	
		goalColor = T(103,2);
		Ot(-12,-90,0,40,0);	
		Od2(-20,0,-70,40,-50,60,130);	cw
		
		CPsd(12,8,5,3,18,0,50,60);
		CPsd(10,8,50,5,18,0,50,0);
	}
	
	line = CPsd(13,8,1000,5,18,0,50,0);
	
	if(line == goalColor){
		Ad(-3,45,90,40,-50,100);

		ar ab45(30);
		area = 1;
		dir = 1;
	}
	else{
		block[1][0] = 1;
		block[0][1] = 1;
		blockDetect = 1;
		Drift(0,10,-20,40,-50);	wa = -20;

		CPsd(12,6,-5,3,14,0,50,60);
		CPsd(10,6,-60,5,14,0,50,0);
		CPsd(-5,6,-1000,5,14,22,50,0);
		Ot(-12,-90,-20,40,0);	wa = -40;
		Axis(-5,0,0,40,0);	wa = 50;
		Ot(-20,90,0,40,0);	wa = -40;
		Ad(0,-15,40,40,-50,60);	cw
		
		ar ab645(20);
		area = 0;
		dir = -1;
	}
}

lcs 
lcd(1,1,"area : %d",area);	
lcd(2,1,"goalColor : %d",goalColor);	wait

start = area;

for(int i = 0 ; i < 3 ; i++){
	while(1){
		
		
		lcs lcd(1,1,"AREA %d",area);	
		lcd(2,1,"SOLVE %d",solve[area]);	wait

		if(!solve[area])
			if(area % 5 || (area == 5 && sColor[0]) || (area == 0 && sColor[1])) 
				SolveArea(area);
		
		if(i == 2 && ((aGate / 2 == 0 && area == 5) || (aGate / 2 == 1 && area == 0))) break;
	
		int next = (area + dir) < 0 ? 5 : (area + dir)%6;

		if(MoveArea(area,next) < 0) {
			blockDetect = 1;
			block[area][next] = block[next][area] = 1;
			break;
		}
		else {
			area = next;
		}
	}
	dir *= -1;
}


if(aGate == 0 || aGate == 1){
	ar ab345(30);
	gyroSet	

	Drift(0,14,30,35,45);	wa = 30;
	Ot(20,90,-10,40,0);	wa = 20;
	Drift(-8,1,-20,30,0);	cw
	
	if(aGate == 0){
		CPsd(12,1,5,3,14,0,50,60);
		CPsd(10,1,20,5,14,0,50,0);
		CPsd(8,1,1000,5,14,30,50,0);
		CPsd(10,1,10,5,14,0,50,0);
		Drift(0,17,-30,35,0);	wa = -30;
		Ot(25,-90,-60,40,0);	cw
		CPsd(12,1,5,3,14,0,50,0);
		CPsd(10,1,22,3,14,0,50,0);
		Ot(28,-90,90,35,-45);
	}
	else{
		CPsd(12,1,5,3,14,0,50,60);
		CPsd(10,1,8,5,14,0,50,0);
		Drift(0,12,-30,35,0);	wa = -30;
		Ot(25,-90,-60,45,0);	cw
		
		CPsd(12,8,5,3,18,0,50,0);
		CPsd(10,8,22,5,18,0,50,0);
		Ot(28,90,90,40,-50);	
	}
}

else{
	ar ab645(30);
	gyroSet

	Drift(0,14,-30,35,45);	wa = -30;
	Ot(20,-90,10,40,0);	wa = -20;
	Drift(8,1,20,30,0);	cw
	
	if(aGate == 2){
		CPsd(12,8,5,3,18,0,50,60);
		CPsd(10,8,20,5,18,0,50,0);
		CPsd(1,8,1000,5,18,25,50,0);
		CPsd(10,8,10,5,18,0,50,0);
		Drift(0,12,30,35,0);	wa = 30;
		Ot(25,90,60,40,0);	cw
		CPsd(12,8,5,3,18,0,50,0);
		CPsd(10,8,22,3,18,0,50,0);
		Ot(28,90,-90,35,-45);
	}
	else{
		CPsd(12,8,5,3,18,0,50,60);
		CPsd(10,8,8,5,18,0,50,0);
		Drift(0,12,30,35,0);	wa = 30;
		Ot(25,90,60,45,0);	cw
		
		CPsd(12,1,5,3,14,0,50,0);
		CPsd(10,1,22,5,14,0,50,0);
		Ot(28,-90,-90,40,-50);	
	}
}

FixAngle(0,10);
set

for(int t = 0 ; t < 2 ; t++){
	Setting(12);
	col[0] = T(-102,2);
	col[1] = T(102,2);
	
	for(int i = 0 ; i < 2 ; i++){
		if(col[i] != goalColor) continue;
		set

		ar TB2(col[i],tx,ty);	wa = pos[2];
		Axis(0,11,0,30,140);	
		Ad(0,-pos[1],-pos[2],30,140,10);	cw
	}
	
	if(t) break;
	Axis(0,0,180,130,120);
	FixAngle(180,10);
}

SS();
LED_ON(3);
_delay_ms(2000);
LED_OFF(3);

case -4:

///

ar ab645(30);
Drift(0,15,-30,40,50);	wa = -30;
Ot(22,-90,10,40,0);	wa = -20;

Drift(8,0,20,30,0);	cw

CPsd(12,8,5,3,18,0,50,60);
CPsd(10,8,5,5,18,0,50,0);
CPsd(1,8,1000,5,18,20,50,0);

Drift(0,20,20,40,0);	wa = 20;

Ot(25,90,70,40,0);	cw

//75

CPsd(12,8,5,3,21,0,50,0);
CPsd(10,8,22,5,21,0,50,0);
Ot(25,90,-90,40,-50);


case -5:

ar ab645(30);
Drift(0,15,-30,40,50);	wa = -30;
Ot(22,-90,10,40,0);	wa = -20;

Drift(8,0,20,30,0);	cw

CPsd(12,8,5,3,18,0,50,60);
CPsd(10,8,10,5,18,0,50,0);

Drift(0,10,20,40,0);	wa = 20;
Ot(25,90,70,40,0);	cw

//75

CPsd(12,1,5,3,18,0,50,0);
CPsd(10,1,22,5,18,0,50,0);
Ot(25,-90,-90,40,-50);





//왼쪽 18
//오른쪽 22

while(!SW2);
while(SW2);

			}
		}

		if(key){
			lcd(0,0,"%03d %03d %03d %03d %03d",g_psd[2],g_psd[1],g_psd[0],g_psd[8],g_psd[7]);
			lcd(1,0,"%03d %03d     %03d %03d",g_psd[3],g_psd[4],g_psd[5],g_psd[6]);
		}
		else{
			lcd(0,0,"%03d %03d %03d %03d %03d",psd[2],psd[1],psd[0],psd[8],psd[7]);
			lcd(1,0,"%03d %03d     %03d %03d",psd[3],psd[4],psd[5],psd[6]);
		}
		key_puck = abs(key) %9;

		get_gyro();
		lcd(2,0,"C%d X%3d Y%3d S%2d",key_puck,Cmd(key_puck,102),Cmd(key_puck,103),Cmd(key_puck,104));		
		lcd(3,0,"%d%d%d%d%d| G%04d",IR_4,IR_1,IR_2,IR_3,IR_5,(int)gyro);
		lcd(3,16,"k:%02d",key);
	}
}


//한 구역에서 다른 구역으로 이동  
//라인 스캔하며 이동 --> 다른 라인인 경우 -1을 리턴함 
//구역이 스캔된 경우 / 스캔되지 않은 경우 상정해 수행함 (3-2)구역의 경우 한번 스캔하면 스캔할 이유 없음 

int MoveArea(int from, int to){
	if(blockDetect && block[from][to]) return -1; //막혀있으면 안지나감 
	//정방향 
	lcs lcd("MOVE %d -> %d",from,to);	wait
	if(from == 0 && to == 1){
		ar ab645(30);
		
		Drift(0,15,-30,40,50);	wa = -30;
		Ot(20,-90,10,40,0);	wa = -20;
		Drift(8,0,20,35,0);	cw

		CPsd(12,8,5,3,20,0,60,70);
		CPsd(10,8,65,5,20,0,60,0);
		if(CPsd(13,8,1000,5,20,0,60,0) == goalColor){
			Drift(-3,38,90,45,-55);
			ar ab45(30); SS();
		}
		else{
			
			Drift(0,10,-20,40,-50);	wa = -20;

			CPsd(12,6,-5,3,14,0,50,60);
			CPsd(10,6,-60,5,14,0,50,0);
			CPsd(-5,6,-1000,5,14,22,50,0);
			Ot(-12,-90,-20,40,0);	wa = -40;
			Axis(-5,0,0,40,0);	wa = 50;
			Ot(-20,90,0,40,0);	wa = -40;
			Ad(0,-15,40,40,-50,60);	cw
		
			ar ab645(20);
	
			return -1;
		}
		
	}
	else if(from == 1 && to == 2){
		ar ab45(20);

		Od2(-20,0,-90,20,130,60,130);

		CPsd(12,8,5,3,18,0,50,60);
		CPsd(10,8,5,5,18,0,50,0);
		
		if(CPsd(13,8,1000,5,18,0,50,0) == goalColor){

			CPsd(10,8,15,5,18,0,50,0);
			Drift(-3,40,90,40,-50);	

			ar ab45(20);
		
			if(g_psd[7] > 30){move_ab845(30);}
			else{	ar ab645(20);}
		}
		else{
			
			Drift(0,10,20,40,-50);	wa = 20;
			CPsd(12,5,-10,3,14,0,50,60);
			CPsd(10,5,-80,5,14,0,50,-60);
			Od2(-2,20,70,20,130,100,120);	cw

			ar ab45(20);

			return -1;
		}
	}
	else if(from == 2 && to == 3){
		bGate[1] = (g_psd[7] > 30);
		
		if(!sColor[1]){
			if(bGate[1]){

				Od2(-15,2,-90,40,150,60,130);	
			
				reset
				CPsd(12,8,5,3,23,0,40,50);
				CPsd(10,8,42,5,23,0,40,-50);
				Axis(0,0,70,100,120);	wa = 70;

				lcs lcd(1,1,"bar_2 %d",bar_2);
				sColor[1] = bar_2;

				Drift(-3,17,20,30,140);	cw
			}	
			else{

				Drift(1,28,-60,40,50);	wa = -60;
				Ot(25,-90,-60,40,0);	wa = -30;
				Ad(2,25,-60,40,-50,60);	cw
				FixAngle(-90,10);
			
				reset

				CPsd(12,1,5,3,11,0,40,50);
				CPsd(10,1,5,5,11,0,40,0);
				CPsd(0,1,1000,5,11,45,40,0);
				CPsd(10,1,15,5,11,0,40,-50);
			
			
				lcs lcd(1,1,"bar :%d",bar_4);
				sColor[1] = bar_4;
				wait
			
				Drift(0,-10,-15,30,40);	wa = -15;
				CPsd(12,3,-5,3,4,0,40,0);
				CPsd(10,3,-45,5,4,0,40,-50);
				Ad(3,30,-75,30,140,100);	cw
				ar ab45(20);
				
				Axis(0,-2,0,10,120);
				Drift(-20,0,-70,30,40);	wa = 20;

				CPsd(12,5,-5,3,11,0,35,0);
				CPsd(10,5,-5,5,11,0,40,0);
				CPsd(-4,5,-1000,5,11,20,40,0);
				Ad(0,-10,-20,40,-50,40);	cw	
			}
		}
		else{
			if(bGate[1] == 0){
				ar ab645(30);
				
				Drift(1,28,-60,40,50);	wa = -60;
				Ot(25,-90,0,40,0);		wa = 30;
				Drift(0,23,60,35,0);	cw
			}
			else{
				Od2(-20,0,-90,30,140,60,130);
				CPsd(12,8,5,3,18,0,40,50);
				CPsd(10,8,25,5,18,0,40,0);
				Drift(-3,38,90,40,0);
			}
		}
		
		if(!sColor[0]){
			CPsd(12,8,5,3,15,0,40,50);
			CPsd(10,8,5,5,15,0,40,0);

			if(CPsd(13,8,1000,5,15,0,40,0) == goalColor){
		
				CPsd(0,8,1000,5,15,40,50,0);
				reset

				CPsd(10,8,15,5,15,40,50,-60);
					
				lcs lcd(1,1,"bar : %d",bar_5);
				sColor[0] = bar_5;
				wait
		
				bGate[0] = (g_psd[2] > 30)? 0 : 1;
		
				if(bGate[0] == 0){
			
					Od2(-2,20,90,20,130,100,120);	ar ab645(30);
			
					Drift(-3,50,90,40,150);
					move_ab145(20);
				}
				else{
					Axis(0,-8,0,40,50);
					Ot(-25,-90,-70,35,0);	wa = 20;
					Ot(-30,-90,-90,35,0);	
					Drift(0,-15,-20,40,-50);	cw
			
					ar ab345(20);
				}
			}
			else{
				if(bGate[0] == 1){
					Drift(0,10,20,35,-45);	wa = 20;
					Ot(-25,-90,-70,35,45);	wa = 40;
					Ot(-30,90,0,40,0);
					Drift(20,0,50,30,-40);	cw
					
					ar ab645(30);
				}
				else{
					Drift(0,10,-20,35,-45);	wa = -20;

					CPsd(12,6,-5,3,11,0,40,50);
					CPsd(10,6,-5,3,11,0,40,0);
					CPsd(-5,6,-1000,3,11,23,40,0);
					Ot(-12,-90,0,40,0);
					
					Drift(-20,-1,-50,35,0);	wa = 20;
					
					CPsd(12,5,-5,3,11,0,40,50);
					CPsd(10,5,-35,3,11,0,40,-50);
					Od2(-2,20,70,30,140,100,120);	
					move_ab845(20);
				}

				return -1;
			}
		}

		else{
			if(bGate[0] == 0){
				
				CPsd(12,8,5,3,15,0,50,60);
				CPsd(10,8,5,5,15,0,50,0);
				CPsd(13,8,1000,5,15,0,50,0);

				CPsd(1,8,1000,5,15,30,50,0);
				Drift(-3,41,90,35,0);

				CPsd(12,8,5,3,15,0,50,60);
				CPsd(10,8,5,3,15,0,50,0);
				Ad(-3,40,90,50,-60,80);	

				move_ab145(20);
			}
			else{
				CPsd(12,8,5,3,15,0,50,60);
				CPsd(13,8,1000,5,15,0,50,0);

				Drift(0,12,20,40,0);	wa = 20;
				Ot(28,90,90,40,0);
				Ot(28,-90,40,40,0);	wa = 60;
				Drift(23,2,30,40,-50);	cw
				ar ab345(30);
			}
		}
	}
	else if(from == 3 && to == 4){
		At(-90,100);
		set
		CPsd(12,8,5,3,18,0,50,60);
		CPsd(10,8,5,5,18,0,50,0);
		
		if(CPsd(13,8,1000,5,18,0,50,0) == goalColor){
			Drift(-3,37,90,40,-50);
			ar ab45(20);
		}
		else{
			Drift(0,10,20,40,-50);	wa = 20;
			
			int y = pos[1];

			CPsd(12,5,-5,3,14,0,40,50);
			CPsd(10,5,-y + 15,5,14,0,40,0);
			Ad(0,-10,70,40,-50,100);	cw

			ar ab45(20);
			if(g_psd[2] > 30){move_ab145(20);}
			else {ar ab345(30);}
			
			return -1;
		}	
	}
	else if(from == 4 && to == 5){
		ar ab45(20);

		if(blockDetect && block[4][5] == 0){
			Drift(30,0,110,30,40);	wa = 20;

			CPsd(12,3,-5,3,18,0,50,0);
			CPsd(10,3,-60,5,18,0,50,0);
			CPsd(-4,3,-1000,5,18,22,50,0);
			Ot(-12,90,20,40,0);	wa = 40;
			Axis(5,0,0,40,0);	wa = -50;
			Ot(-20,-90,0,40,0);	wa = 40;
			Ad(0,-12,-40,40,-50,60);	cw

			ar ab345(20);
			area = 5;			

		}

		else{
			Od2(-20,0,-90,40,150,60,130);	
			CPsd(12,8,5,3,18,0,60,70);
			CPsd(10,8,5,5,18,0,60,0);

			if(CPsd(13,8,1000,5,18,0,60,0) == goalColor){
				CPsd(10,8,100,5,18,0,60,0);
				CPsd(0,8,1000,5,18,40,60,0);
				Drift(0,9,20,45,0);		wa = 20;
				Ot(20,90,70,40,0);	cw
				Ot(15,-90,20,40,0);	wa = 20;
				Ad(10,0,70,40,-50,100);	cw

				ar ab345(30);
			}
			else{
				Drift(0,10,20,50,-60);	wa = 20;
				CPsd(12,5,-10,3,14,0,50,60);
				CPsd(10,5,-80,3,14,0,50,-60);
				Od2(-2,18,70,20,130,100,120);	cw
				ar ab45(20);

				return -1;
			}
		}
	}
	else if(from == 5 && to == 0){		
		ar ab345(30);
		gyroSet
		set

		V3
		Setting(12);
		At(-90,100);	
		
		ar ab645(30);
		
		if(!solve[6]){
			int col = T(103,2);
			
			if(Cmd(col,102) < 55 || Cmd(col,103) < 30)	 cGate = 1;
			else cGate = 0;

			Axis(-30,0,0,40,150);
			ar AB(0,0,1,102,0,0,20,0);
			
			col = T(103,2);
			
			if(col == goalColor){
				set ar TB2(col,tx,ty);	wa = pos[2];
				Axis(0,17,0,20,130);
				Ad(0,-pos[1],-pos[2],30,140,60);	cw
				FixAngle(-90,10);		
			}
		}			

		if(cGate == 0){
			if(solve[6])	Axis(-30,0,0,30,40);
			CPsd(12,1,5,3,12,0,50,60);
			CPsd(10,1,15,5,12,0,50,0);
			Axis(0,20,0,50,0);

			CPsd(12,1,5,3,12,0,50,0);
			CPsd(10,1,5,5,12,0,50,0);
			CPsd(1,1,1000,5,12,20,50,0);
			Ot(10,-90,20,35,0);	wa = 20;
			Ad(15,0,70,40,-50,100);		cw

			ar ab645(30);
		}

		else{
			if(!solve[6])	Axis(30,0,0,30,40);
			CPsd(12,8,10,3,16,0,50,60);
			CPsd(10,8,40,5,16,0,50,0);
			Drift(-3,40,90,40,-50);

			ar ab645(20);
		}

		solve[6] = 1;
	}


	

	//역방향 
	if(from == 0 && to == 5){
		V3
		
		ar ab645(30);
		set
		gyroSet

		Setting(12);
		At(90,100);	
		
		ar ab345(30);
		
		if(!solve[6]){
			int col = T(103,2);
			if(Cmd(col,102) > 210 || Cmd(col,103) < 30)	 cGate = 1;
			else cGate = 0;

			Axis(30,0,0,40,150);
			ar AB(0,0,8,112,0,0,20,0);

			col = T(103,2);
			
			if(col == goalColor){
				set ar TB2(col,tx,ty);	wa = pos[2];
				Axis(0,17,0,20,130);
				Ad(0,-pos[1],-pos[2],30,140,60);	cw
				FixAngle(90,10);		
			}
		}
		
		if(cGate == 0){
			if(solve[6])	Axis(30,0,0,30,40);
			CPsd(12,8,5,3,16,0,50,60);
			CPsd(10,8,15,5,16,0,50,0);
			Axis(0,20,0,50,0);

			CPsd(12,8,5,3,16,0,50,0);
			CPsd(10,8,5,5,16,0,50,0);
			CPsd(8,8,1000,5,16,25,50,0);
			Ot(15,90,-20,40,0);	wa = -20;
			Ad(-15,0,-70,40,-50,100);		cw

			ar ab345(30);
		}

		else{
			if(!solve[6])	Axis(-30,0,0,30,40);
			CPsd(12,1,10,3,12,0,50,60);
			CPsd(10,1,40,5,12,0,50,0);
			Drift(3,40,-90,40,-50);

			ar ab345(20);
		}
		solve[6] = 1;
	}
	else if(from == 5 && to == 4){
		ar ab345(30);
		
		Drift(0,15,30,40,50);	wa = 30;
		Ot(20,90,-10,40,0);	wa = 20;
		Drift(-8,0,-20,35,0);	cw

		CPsd(12,1,5,3,14,0,60,70);
		CPsd(10,1,50,5,14,0,60,0);
	
		if(CPsd(13,1,1000,5,14,25,60,0)){
			CPsd(8,1,1000,5,14,25,60,0);

			Drift(3,43,-90,45,-55);	
			ar ab45(20);
		}		
		
		else{
			Drift(0,10,20,40,-50);	wa = 20;

			CPsd(12,3,-5,3,18,0,50,60);
			CPsd(10,3,-60,5,18,0,50,0);
			CPsd(-4,3,-1000,5,18,22,50,0);
			Ot(-12,90,20,40,0);	wa = 40;
			Axis(5,0,0,40,0);	wa = -50;
			Ot(-20,-90,0,40,0);	wa = 40;
			Ad(0,-15,-40,40,-50,60);	cw

			ar ab345(30);	

			return -1;
		}

	}
	else if(from == 4 && to == 3){
		ar ab45(20);

		Od2(20,0,90,20,130,60,130);

		CPsd(12,1,5,3,14,0,50,60);
		CPsd(10,1,5,5,14,0,50,0);
		
		if(CPsd(13,1,1000,5,14,0,50,0) == goalColor){

			CPsd(10,1,15,5,14,0,50,0);
			Drift(3,40,-90,40,-50);	

			ar ab45(20);
		
			if(g_psd[2] > 30){move_ab145(30);}
			else{	ar ab345(20);	}
		}
		else{
			Drift(0,10,-20,40,-50);	wa = -20;
			CPsd(12,4,-10,3,18,0,50,60);
			CPsd(10,4,-30,5,18,0,50,-60);
			Od2(2,20,-70,20,130,100,120);	cw

			ar ab45(20);
		}	
	}
	else if(from == 3 && to == 2){
		bGate[0] = (g_psd[2] > 30)? 0 : 1;
		
		if(!sColor[0]){
			if(bGate[0] == 0){

				Od2(15,2,90,40,150,60,130);	
			
				reset
				CPsd(12,1,5,3,18,0,40,50);
				CPsd(10,1,42,5,18,0,40,-50);
				Axis(0,0,-70,100,120);	wa = -70;

				lcs lcd(1,1,"bar_2 %d",bar_2);
				sColor[0] = bar_2;

				Drift(3,17,-20,30,140);	cw
			}	
			else{

				Drift(-1,28,60,40,50);	wa = 60;
				Ot(25,90,60,40,0);	wa = 30;
				Ad(-2,25,60,40,-50,60);	cw
				FixAngle(90,10);
			
				reset

				CPsd(12,8,5,3,16,0,40,50);
				CPsd(10,8,5,5,16,0,40,0);
				CPsd(0,8,1000,5,16,45,40,0);
				CPsd(10,8,15,5,16,0,40,-50);
			
			
				lcs lcd(1,1,"bar :%d",bar_4);
				sColor[0] = bar_4;
				wait
			
				Drift(0,-10,15,30,40);	wa = 15;
				CPsd(12,5,-5,3,14,0,40,0);
				CPsd(10,5,-45,5,14,0,40,-50);
				Ad(-3,30,75,30,140,100);	cw
				ar ab45(20);
				
				Axis(0,-2,0,10,120);
				Drift(20,0,70,30,40);	wa = -20;

				CPsd(12,4,-5,3,16,0,35,0);
				CPsd(10,4,-5,5,16,0,40,0);
				CPsd(-5,4,-1000,5,16,20,40,0);
				Ad(0,-10,20,40,-50,40);	cw	
			}
		}
		else{
			if(bGate[0] == 1){
				ar ab345(30);
				
				Drift(-1,28,60,40,50);	wa = 60;
				Ot(25,90,0,40,0);		wa = -30;
				Drift(0,23,-60,35,0);	cw
			}
			else{
				Od2(20,0,90,30,140,60,130);
				CPsd(12,1,5,3,14,0,40,50);
				CPsd(10,1,25,5,14,0,40,0);
				Drift(3,38,-90,40,0);
			}
		}
		
		if(!sColor[1]){
			CPsd(12,1,5,3,11,0,40,50);
			CPsd(10,1,5,5,11,0,40,0);

			if(CPsd(13,1,1000,5,11,0,40,0) == goalColor){
		
				CPsd(0,1,1000,5,11,40,50,0);
				reset

				CPsd(10,1,15,5,11,40,50,-60);
					
				lcs lcd(1,1,"bar : %d",bar_5);
				sColor[1] = bar_5;
				wait
		
				bGate[1] = (g_psd[7] > 30)? 0 : 1;
		
				if(bGate[1] == 0){
			
					Od2(2,20,-90,20,130,100,120);	ar ab345(30);
			
					Drift(3,50,-90,40,150);
					move_ab845(20);
				}
				else{
					Axis(0,-8,0,40,50);
					Ot(-25,90,70,35,0);	wa = -20;
					Ot(-30,90,90,35,0);	
					Drift(0,-15,20,40,-50);	cw
			
					ar ab645(20);
				}
			}
			else{
				if(bGate[0] == 1){
					Drift(0,10,-20,35,-45);	wa = -20;
					Ot(-25,90,70,35,45);	wa = -40;
					Ot(-30,-90,0,40,0);
					Drift(-20,0,-50,30,-40);	cw
					ar ab345(30);
				}
				else{
					Drift(0,10,20,35,-45);	wa = 20;

					CPsd(12,3,-5,3,15,0,40,50);
					CPsd(10,3,-5,3,15,0,40,0);
					CPsd(-4,3,-1000,3,15,23,40,0);
					Ot(-12,90,0,40,0);
					
					Drift(20,-1,50,35,0);	wa = -20;
					
					CPsd(12,4,-5,3,15,0,40,50);
					CPsd(10,4,-35,3,15,0,40,-50);
					Od2(2,20,-70,30,140,100,120);	
					move_ab145(20);
				}

				return -1;
			}
		}

		else{
			if(bGate[1] == 1){
				
				CPsd(12,1,5,3,11,0,50,60);
				CPsd(10,1,5,5,11,0,50,0);
				CPsd(13,1,1000,5,11,0,50,0);

				CPsd(8,1,1000,5,11,30,50,0);
				Drift(3,41,-90,35,0);

				CPsd(12,1,5,3,11,0,50,60);
				CPsd(10,1,5,3,11,0,50,0);
				Ad(3,40,-90,50,-60,80);	

				move_ab845(20);
			}
			else{
				CPsd(12,1,5,3,11,0,50,60);
				CPsd(13,1,1000,5,11,0,50,0);

				Drift(0,12,-20,40,0);	wa = -20;
				Ot(28,-90,-90,40,0);
				Ot(28,90,-40,40,0);	wa = -60;
				Drift(-23,2,-30,40,-50);	cw
				ar ab645(30);
			}
		}
	}

	else if(from == 2 && to == 1){
		At(90,100);	cw
		set
		CPsd(12,1,5,3,15,0,50,60);
		CPsd(10,1,5,5,15,0,50,0);
				
		if(CPsd(13,1,1000,5,15,0,50,0) == goalColor){
			CPsd(8,1,1000,3,15,30,50,0);
			Drift(3,43,-90,40,-50);
			ar ab45(20);
		}
		else{
			Drift(0,10,-20,40,-50);	wa = -20;
				
			int y = pos[1];
			CPsd(12,4,-5,3,18,0,40,50);
			CPsd(10,4,-y + 15,5,18,0,40,0);
			Ad(2,-10,-70,40,-50,100);	cw
			
			if(g_psd[7] > 30)	{move_ab845(20);}
			else	{ar ab645(30);}
			return -1;
		}
	}
	else if(from == 1 && to == 0){
		ar ab45(20);
		
		if(blockDetect && !block[1][0]){
			Drift(-30,0,-110,30,40);	wa = -20;

			CPsd(12,6,-5,3,14,0,50,0);
			CPsd(10,6,-60,5,14,0,50,0);
			CPsd(-5,6,-1000,5,14,22,50,0);
			Ot(-12,-90,-20,40,0);	wa = -40;
			Axis(-5,0,0,40,0);	wa = 50;
			Ot(-20,90,0,40,0);	wa = -40;
			Ad(0,-12,40,40,-50,60);	cw
	
			ar ab645(20);
		}
		else{
			Od2(20,0,90,40,150,60,130);	
			CPsd(12,1,5,3,14,0,60,70);
			CPsd(10,1,5,5,14,0,60,0);

			if(CPsd(13,1,1000,5,14,0,60,0) == goalColor){
				CPsd(10,1,100,5,14,0,60,0);
				CPsd(0,1,1000,5,14,40,60,0);
				
				Drift(0,11,-20,45,0);		wa = -20;
				Ot(20,-90,-70,40,0);	cw
				Ot(15,90,-20,40,0);	wa = -20;
				Ad(-10,0,-70,40,-50,100);	cw

				ar ab645(30);
			}
			else{
				Drift(0,10,-20,50,-60);	wa = -20;
				CPsd(12,4,-10,3,18,0,50,60);
				CPsd(10,4,-30,3,18,0,50,-60);
				Od2(2,18,-70,20,130,100,120);	cw
				ar ab45(20);
				return -1;
			}
		}
	}
	return 1;
}

//Area에 맞는 동작을 수행 
void SolveArea(int area){ 
	solve[area] = 1;

	if(area == 0){
		ar ab645(20);
		
		gyroSet
		Ad(-20,0,-90,40,150,60);	
		FixAngle(-90,10);

		int left = T(-102,2);
		int right = T(102,2);
		
		if(left == sColor[1]){
			AB(0,92,0,0,0,0,0,20);	

			Od2(0,20,40,20,130,100,120);	
			Axis(0,0,-60,130,120);
			
			FixAngle(0,100);
			ar ab645(30);
		}		
		else if(right == sColor[1]){
			AB(0,92,0,0,0,0,0,20);	

			set			
			ar TB2(right,tx,ty);	wa = pos[2];
			
			Axis(0,17,0,30,140);	
			Drift(0,-10,-pos[2],30,140);	cw
			Axis(0,8,0,20,30);
			Od2(0,5,-30,20,-30,100,120);	wa = -30;
			Ad(0,-30,30,40,150,60);	cw
			FixAngle(-90,10);

			Drift(-3,25,90,30,140);
			ar ab645(30);
		}		
	}

	else if(area == 1 || area == 4){
		ar ab45(20);
		CPsd(12,1,5,3,11,0,40,50);
		CPsd(10,1,5,5,11,0,40,0);
		Drift(2,38,-90,30,-40);
		
		Axis(0,2,0,10,120);
		ar ab345(20);
		Axis(-2,0,0,10,120);

		if(T(101,3) == goalColor){
			CPsd(12,1,4,3,12,0,20,30);
			CPsd(10,1,10,5,12,0,20,-30);

			Axis(0,-12,0,30,140);
			ar ab345(30);
		}
		Axis(0,-2,0,10,120);
		Drift(48,0,90,30,140);

		ar ab45(20);
	}

	else if(area == 2){
		At(30,60);	wa = 30;

		col[0] = Scan(69,88);
		col[1] = Scan(111,63);
		col[2] = Scan(142,42);
		At(-30,60);	cw
		
		ar ab45(20);

		for(int i = 0; i < 3 ; i++){
			if(col[i] == goalColor){
				set
				Ad(0,11 + 12 *i,50,30,140,40);	wa = 50;
				Axis(-8,8,0,20,130);
				Axis(8,-8,0,20,130);

				Ad(0,-11 - 12*i,-50,30,140,60);	cw

				if(g_psd[7] > 30) {move_ab845(20);}
				else {Axis(-2,2,0,10,120);ar ab645(30);}
			}
		}	
	}

	else if(area == 3){
		At(-30,60);	wa = 30;
		col[0] = Scan(170,82);
		col[1] = Scan(132,56);
		col[2] = Scan(102,38);


		At(30,60);	cw
		
		ar ab45(20);
		for(int i = 0; i < 3 ; i++){
			if(col[i] == goalColor){
				set
				Ad(0,11 + 12 *i,-50,30,140,40);	wa = -50;
				Axis(8,8,0,20,130);
				Axis(-8,-8,0,20,130);

				Ad(0,-11 - 12*i,50,30,140,60);	cw

				if(g_psd[2] > 30) {move_ab145(20);}
				else {Axis(2,2,0,10,120);ar ab345(30);}
			}
		}
	}

	else if(area == 5){
		ar ab345(20);
		
		gyroSet
		Ad(20,0,90,40,150,60);	
		FixAngle(90,10);

		int left = T(-102,2);
		int right = T(102,2);
		
		if(right == sColor[0]){
			AB(0,92,0,0,0,0,0,20);	
			set

			Od2(0,20,-40,20,130,100,120);	
			Axis(0,0,60,130,120);
			
			FixAngle(0,100);
			ar ab345(30);
		}		
		else if(left == sColor[0]){
			set

			AB(0,92,0,0,0,0,0,20);	

			set			
			ar TB2(left,tx,ty);	wa = pos[2];
			
			Axis(0,17,0,30,140);	
			Drift(0,-10,-pos[2],30,140);	cw
			Axis(0,8,0,20,30);
			Od2(0,5,30,20,-30,100,120);	wa = 30;
			Ad(0,-30,-30,40,150,60);	cw
			FixAngle(90,10);

			Drift(3,25,-90,30,140);
			ar ab345(30); SS();
		}			
	}
}


int Scan(int x, int y){
	
	for(int t = 0 ; t < 3 ; t++){
		SV1
		V1();
		V3

		for(int i = 0 ; i < 9 ; i++){
			if(!pro[i][0]) continue;

			if(abs(pro[i][1] - x) < 13 && abs(pro[i][2] - y) < 13) return pro[i][0];
		}
	}

	return 0;
}
